{"ast":null,"code":"import { objectWithoutProperties as _objectWithoutProperties, slicedToArray as _slicedToArray, extends as _extends, objectSpread as _objectSpread, defineProperty as _defineProperty } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport React, { forwardRef, useState, useEffect, useCallback } from 'react';\nimport classNames from 'classnames';\nimport find from 'lodash/find';\nimport warning from 'warning';\nimport canUseDOM from '../../utils/can-use-dom.js';\nimport useLazyLoad from './use-lazy-load.js';\nimport styles from './index.module.scss'; // Steps in rendering Image\n//\n// 1. Picture is rendered without src, srcSets, and with a padding-top placholder on the <img>\n// based on the containerAspectRatio.\n// 2. The \"sizes\" attr is calculated on initial render to determine width of image.\n// 3. When lazyload is triggered the src and scrSet props are populated based on the sizes value.\n// 4. The image is set to opacity:0 to start to prevent flash of alt text\n// 5. The image onLoad and onError events remove padding-top placholder and sets opacity to 1.\n// --------------------------------------------------------------------------------------------\n\nvar Image = forwardRef(function (props, outerRef) {\n  var _classNames;\n\n  var src = props.src,\n      _props$sources = props.sources,\n      sources = _props$sources === void 0 ? [] : _props$sources,\n      height = props.height,\n      containerAspectRatio = props.containerAspectRatio,\n      _props$objectFit = props.objectFit,\n      objectFit = _props$objectFit === void 0 ? 'cover' : _props$objectFit,\n      _props$objectPosition = props.objectPosition,\n      objectPosition = _props$objectPosition === void 0 ? 'center' : _props$objectPosition,\n      _props$alt = props.alt,\n      alt = _props$alt === void 0 ? '' : _props$alt,\n      className = props.className,\n      _props$forceEarlyRend = props.forceEarlyRender,\n      forceEarlyRender = _props$forceEarlyRend === void 0 ? null : _props$forceEarlyRend,\n      rest = _objectWithoutProperties(props, [\"src\", \"sources\", \"height\", \"containerAspectRatio\", \"objectFit\", \"objectPosition\", \"alt\", \"className\", \"forceEarlyRender\"]); // The outermost DOM node that this component references. We use `useState` instead of\n  // `useRef` because callback refs allow us to add more than one `ref` to a DOM node.\n\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      containerRef = _useState2[0],\n      setContainerRef = _useState2[1]; // --------------------------------------------------------------------------------------------\n  // Sizes\n  // --------------------------------------------------------------------------------------------\n  // Used by srcSet to determine which image in the list will be requested. This value has to be\n  // calculated client-side because we don't know the viewport width.\n\n\n  var computeSizes = function computeSizes() {\n    return containerRef && containerRef.clientWidth ? \"\".concat(containerRef.clientWidth, \"px\") : '0px';\n  }; // If `forceEarlyRender` is truthy use that value, otherwise use the computed width.\n\n\n  var sizes = forceEarlyRender || computeSizes(); // --------------------------------------------------------------------------------------------\n  // Lazy-loading: library setup and polyfill\n  // --------------------------------------------------------------------------------------------\n\n  var _useState3 = useState(canUseDOM && typeof window.IntersectionObserver !== 'undefined'),\n      _useState4 = _slicedToArray(_useState3, 2),\n      browserSupportIntersectionObserver = _useState4[0],\n      setBrowserSupportIntersectionObserver = _useState4[1];\n\n  var shouldLoad = useLazyLoad(containerRef, browserSupportIntersectionObserver); // Loads the `IntersectionObserver` polyfill asynchronously on browsers that don't support it.\n\n  if (canUseDOM && typeof window.IntersectionObserver === 'undefined') {\n    import('intersection-observer').then(function () {\n      setBrowserSupportIntersectionObserver(true);\n    });\n  } // If `forceEarlyRender` is truthy, bypass lazy loading and load the image.\n\n\n  var shouldLoadImage = shouldLoad || forceEarlyRender; // --------------------------------------------------------------------------------------------\n  // Object Fit: polyfill and CSS styles\n  // --------------------------------------------------------------------------------------------\n\n  var objectFitProps = {}; // Checking for the use of the `height` prop is not enough since users can also change the\n  // image height using `className`, or `style`.\n\n  var shouldObjectFit = !!height || !!props.objectFit;\n  var shouldPolyfillObjectFit = canUseDOM && document.documentElement && document.documentElement.style && 'objectFit' in document.documentElement.style !== true;\n  warning(!height && !containerAspectRatio || height && !containerAspectRatio || !height && containerAspectRatio, 'You can pass either a `height` or `containerAspectRatio` to the `Image` component, but not both.');\n  useEffect(function () {\n    // We polyfill `object-fit` for browsers that don't support it. We only do it if we're\n    // using a `height` or `containerAspectRatio`. The `shouldLoadImage` variable ensures\n    // that we don't try to polyfill the image before the `src` exists. This can happy\n    // when we lazy-load.\n    if (shouldObjectFit && containerRef && shouldLoadImage && shouldPolyfillObjectFit) {\n      import('object-fit-images').then(function (_ref) {\n        var ObjectFitImages = _ref.default;\n        ObjectFitImages(containerRef.querySelector('img'));\n      });\n    }\n  }, [shouldObjectFit, containerRef, shouldLoadImage, shouldPolyfillObjectFit]);\n\n  if (shouldObjectFit) {\n    objectFitProps.style = {\n      objectFit: objectFit,\n      objectPosition: objectPosition\n    };\n\n    if (!height) {\n      // Add `height: 100%` as an inline style if the user wants to `objectFit` but hasn't\n      // passed in the `height` prop. Almost always, this means that the user is setting the\n      // height with CSS or an inline style. Since inline styles and `className` get added to\n      // `picture`, not `img`, the `img` element would become taller than the picture,\n      // preventing the `objectFit` from working. Adding `height: 100%` to the `img` in these\n      // cases allows `objectFit` to work as well as it would if the `height` was provided as\n      // a prop rather than through `style` or `className`.\n      objectFitProps.style.height = '100%';\n    }\n\n    if (shouldPolyfillObjectFit) {\n      // Weird, but this is how the polyfill knows what to do with the image in IE.\n      objectFitProps.style.fontFamily = \"\\\"object-fit: \".concat(objectFit, \"; object-position: \").concat(objectPosition, \"\\\"\");\n    }\n  } // --------------------------------------------------------------------------------------------\n  // Image Aspect Ratio used for image placeholder\n  // --------------------------------------------------------------------------------------------\n\n\n  var aspectRatioBoxProps = {};\n\n  if (containerAspectRatio) {\n    // This ensures that lazy-loaded images don't cause the browser scroll to jump once the\n    // image has loaded. It uses the following technique:\n    // https://css-tricks.com/aspect-ratio-boxes/\n    var h = 100000;\n    var w = h * containerAspectRatio;\n    aspectRatioBoxProps.style = {\n      paddingTop: \"\".concat(h / w * 100, \"%\"),\n      overflow: 'hidden',\n      // Prevents alt text from taking up space before `src` is populated\n      height: 0\n    };\n  } // --------------------------------------------------------------------------------------------\n  // Sources and srcSets\n  // --------------------------------------------------------------------------------------------\n  // We separate `webp` from the `jpeg`/`png` so that we can apply the `imgTagSource` directly\n  // onto the `img` tag. While this makes the code messier, it is needed to work around a bug in\n  // Safari:\n  // - https://bugs.webkit.org/show_bug.cgi?id=190031\n  // - https://bugs.webkit.org/show_bug.cgi?id=177068\n\n\n  var webpSource = find(sources, function (s) {\n    return s.type === 'image/webp';\n  });\n  var imgTagSource = find(sources, function (s) {\n    return s.type === 'image/jpeg' || s.type === 'image/png';\n  }); // --------------------------------------------------------------------------------------------\n  // Image load and error states\n  // --------------------------------------------------------------------------------------------\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isLoaded = _useState6[0],\n      setIsLoaded = _useState6[1];\n\n  var _useState7 = useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      isError = _useState8[0],\n      setIsError = _useState8[1]; // --------------------------------------------------------------------------------------------\n  // Combining refs: This component has three refs that need to be combined into one. This\n  // method of combining refs is suggested by `react-intersection-observer`:\n  // https://github.com/thebuilder/react-intersection-observer#how-can-i-assign-multiple-refs-to-a-component\n  // --------------------------------------------------------------------------------------------\n\n\n  var setRefs = useCallback(function (node) {\n    // Using a callback `ref` on this `picture` allows us to have multiple `ref`s on one\n    // element.\n    setContainerRef(node); // Check if the consumer sets a ref.\n\n    if (typeof outerRef === 'function') {\n      outerRef(node);\n    }\n  }, [outerRef, setContainerRef]);\n  return React.createElement(React.Fragment, null, React.createElement(\"picture\", _extends({}, rest, {\n    className: classNames(styles.picture, className),\n    ref: setRefs\n  }), webpSource && React.createElement(\"source\", {\n    type: webpSource.type // Only add this attribute if lazyload has been triggered.\n    ,\n    srcSet: shouldLoadImage ? webpSource.srcSet : undefined,\n    sizes: sizes\n  }), React.createElement(\"img\", {\n    // The order of `sizes`, `srcSet`, and `src` is important to work around a bug in\n    // Safari. Once the bug is fixed, we should simplify this by using `src` on the\n    // `img` tag and using `source` tags.\n    sizes: sizes // Only add this attribute if lazyload has been triggered.\n    ,\n    srcSet: shouldLoadImage && imgTagSource ? imgTagSource.srcSet : undefined // Only add this attribute if lazyload has been triggered.\n    ,\n    src: shouldLoadImage ? src : undefined // Height is generally only used for full-width hero images.\n    ,\n    height: height,\n    alt: alt // Adds object fit values if specified and adds/removes placeholder padding.\n    // For SSR we want this to fire instantly.\n    ,\n    style: _objectSpread({}, shouldObjectFit ? objectFitProps.style : {}, isLoaded || isError || forceEarlyRender ? {} : aspectRatioBoxProps.style),\n    onLoad: function onLoad() {\n      setIsLoaded(true);\n    },\n    onError: function onError() {\n      setIsError(true);\n    },\n    className: classNames((_classNames = {}, _defineProperty(_classNames, styles.imageStart, true), _defineProperty(_classNames, styles.imageEnd, isLoaded || isError || forceEarlyRender), _classNames))\n  })), !forceEarlyRender && React.createElement(\"noscript\", null, React.createElement(\"img\", {\n    src: src,\n    alt: alt\n  })));\n}); // Needed because of the `forwardRef`.\n\nImage.displayName = 'Image';\nexport default Image;","map":{"version":3,"sources":["../../../../components/Image/index.tsx"],"names":["Image","forwardRef","src","sources","height","containerAspectRatio","objectFit","objectPosition","alt","className","forceEarlyRender","rest","props","containerRef","setContainerRef","useState","computeSizes","sizes","browserSupportIntersectionObserver","setBrowserSupportIntersectionObserver","canUseDOM","window","shouldLoad","useLazyLoad","shouldLoadImage","objectFitProps","shouldObjectFit","shouldPolyfillObjectFit","document","warning","useEffect","default","ObjectFitImages","aspectRatioBoxProps","h","w","paddingTop","overflow","webpSource","find","s","imgTagSource","isLoaded","setIsLoaded","isError","setIsError","setRefs","useCallback","outerRef","classNames","styles"],"mappings":"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","sourcesContent":["import React, { useState, forwardRef, useEffect, useCallback } from 'react';\nimport find from 'lodash/find';\nimport classNames from 'classnames';\nimport warning from 'warning';\nimport canUseDOM from '../../utils/can-use-dom';\nimport useLazyLoad from './use-lazy-load';\nimport styles from './index.module.scss';\n\n// --------------------------------------------------------------------------------------------\n// Steps in rendering Image\n//\n// 1. Picture is rendered without src, srcSets, and with a padding-top placholder on the <img>\n// based on the containerAspectRatio.\n// 2. The \"sizes\" attr is calculated on initial render to determine width of image.\n// 3. When lazyload is triggered the src and scrSet props are populated based on the sizes value.\n// 4. The image is set to opacity:0 to start to prevent flash of alt text\n// 5. The image onLoad and onError events remove padding-top placholder and sets opacity to 1.\n// --------------------------------------------------------------------------------------------\n\ntype ImageSource = {\n    type: 'image/webp' | 'image/jpeg' | 'image/png' | 'image/gif';\n    srcSet: string;\n};\n\ninterface ImagePropTypes {\n    /**\n     * If `sources` is provided, this image will be loaded by search engines and lazy-loaded for\n     * users on browsers that don't support responsive images. If `sources` is not provided, this\n     * image will be lazy-loaded.\n     */\n    src: string;\n    /**\n     * Allows the browser to choose the best file format and image size based on the device screen\n     * density and the width of the rendered image.\n     */\n    sources?: ImageSource[];\n    alt?: string;\n    /**\n     * Crops the image at the provided height. The `objectFit` and `objectPosition` props can be\n     * used to control how the image is cropped.\n     */\n    height?: string;\n    /**\n     * Creates a [placeholder box](https://css-tricks.com/aspect-ratio-boxes/) for the image.\n     * The placeholder prevents the browser scroll from jumping when the image is lazy-loaded.\n     */\n    containerAspectRatio?: number;\n    /**\n     * Disables lazy-loading and overrides the default calculation of the `sizes` attribute.\n     * Primarily for important images in a server-side rendered environment that must be\n     * loaded before JavaScript is parsed and executed on the client. The value gets used\n     * as the `sizes` attribute. [See allowable values](https://mzl.la/2Hh6neO).\n     */\n    forceEarlyRender?: React.ImgHTMLAttributes<HTMLImageElement>['sizes'];\n    /**\n     * Provides control over how the image should be resized to fit the container. This controls the\n     * `object-fit` CSS property. It is only useful if `height` is used to \"crop\" the image.\n     */\n    objectFit?: 'cover' | 'contain';\n    /**\n     * Provides control over how the image position in the container. This controls the\n     * `object-position` CSS property. It is only useful if `height` is used to \"crop\" the image.\n     */\n    objectPosition?: 'top' | 'center' | 'bottom' | 'left' | 'right';\n    className?: string;\n}\n\ntype ObjectFitPropsType = {\n    style?: {\n        // Not using React.CSSProperties types for these two, because we use a restricted subset.\n        objectFit?: 'cover' | 'contain';\n        objectPosition?: 'top' | 'center' | 'bottom' | 'left' | 'right';\n        fontFamily?: React.CSSProperties['fontFamily'];\n        height?: '100%';\n    };\n};\n\ntype AspectRatioBoxPropsType = {\n    style?: {\n        paddingTop?: React.CSSProperties['paddingTop'];\n        overflow?: React.CSSProperties['overflow'];\n        height?: React.CSSProperties['height'];\n    };\n};\n\nconst Image = forwardRef<HTMLElement, ImagePropTypes>((props: ImagePropTypes, outerRef) => {\n    const {\n        src,\n        sources = [],\n        height,\n        containerAspectRatio,\n        objectFit = 'cover',\n        objectPosition = 'center',\n        alt = '',\n        className,\n        forceEarlyRender = null,\n        ...rest\n    } = props;\n\n    // The outermost DOM node that this component references. We use `useState` instead of\n    // `useRef` because callback refs allow us to add more than one `ref` to a DOM node.\n    const [containerRef, setContainerRef] = useState<Element | null>(null);\n\n    // --------------------------------------------------------------------------------------------\n    // Sizes\n    // --------------------------------------------------------------------------------------------\n\n    // Used by srcSet to determine which image in the list will be requested. This value has to be\n    // calculated client-side because we don't know the viewport width.\n\n    const computeSizes = (): string =>\n        containerRef && containerRef.clientWidth ? `${containerRef.clientWidth}px` : '0px';\n\n    // If `forceEarlyRender` is truthy use that value, otherwise use the computed width.\n    const sizes = forceEarlyRender || computeSizes();\n\n    // --------------------------------------------------------------------------------------------\n    // Lazy-loading: library setup and polyfill\n    // --------------------------------------------------------------------------------------------\n\n    const [browserSupportIntersectionObserver, setBrowserSupportIntersectionObserver] = useState<\n        boolean\n    >(canUseDOM && typeof window.IntersectionObserver !== 'undefined');\n\n    const shouldLoad = useLazyLoad(containerRef, browserSupportIntersectionObserver);\n\n    // Loads the `IntersectionObserver` polyfill asynchronously on browsers that don't support it.\n    if (canUseDOM && typeof window.IntersectionObserver === 'undefined') {\n        import('intersection-observer').then(() => {\n            setBrowserSupportIntersectionObserver(true);\n        });\n    }\n\n    // If `forceEarlyRender` is truthy, bypass lazy loading and load the image.\n    const shouldLoadImage = shouldLoad || forceEarlyRender;\n\n    // --------------------------------------------------------------------------------------------\n    // Object Fit: polyfill and CSS styles\n    // --------------------------------------------------------------------------------------------\n\n    const objectFitProps: ObjectFitPropsType = {};\n\n    // Checking for the use of the `height` prop is not enough since users can also change the\n    // image height using `className`, or `style`.\n    const shouldObjectFit = !!height || !!props.objectFit;\n\n    const shouldPolyfillObjectFit =\n        canUseDOM &&\n        document.documentElement &&\n        document.documentElement.style &&\n        'objectFit' in document.documentElement.style !== true;\n\n    warning(\n        (!height && !containerAspectRatio) ||\n            (height && !containerAspectRatio) ||\n            (!height && containerAspectRatio),\n        'You can pass either a `height` or `containerAspectRatio` to the `Image` component, but not both.',\n    );\n\n    useEffect(() => {\n        // We polyfill `object-fit` for browsers that don't support it. We only do it if we're\n        // using a `height` or `containerAspectRatio`. The `shouldLoadImage` variable ensures\n        // that we don't try to polyfill the image before the `src` exists. This can happy\n        // when we lazy-load.\n        if (shouldObjectFit && containerRef && shouldLoadImage && shouldPolyfillObjectFit) {\n            import('object-fit-images').then(({ default: ObjectFitImages }) => {\n                ObjectFitImages(containerRef.querySelector('img'));\n            });\n        }\n    }, [shouldObjectFit, containerRef, shouldLoadImage, shouldPolyfillObjectFit]);\n\n    if (shouldObjectFit) {\n        objectFitProps.style = {\n            objectFit,\n            objectPosition,\n        };\n\n        if (!height) {\n            // Add `height: 100%` as an inline style if the user wants to `objectFit` but hasn't\n            // passed in the `height` prop. Almost always, this means that the user is setting the\n            // height with CSS or an inline style. Since inline styles and `className` get added to\n            // `picture`, not `img`, the `img` element would become taller than the picture,\n            // preventing the `objectFit` from working. Adding `height: 100%` to the `img` in these\n            // cases allows `objectFit` to work as well as it would if the `height` was provided as\n            // a prop rather than through `style` or `className`.\n            objectFitProps.style.height = '100%';\n        }\n\n        if (shouldPolyfillObjectFit) {\n            // Weird, but this is how the polyfill knows what to do with the image in IE.\n            objectFitProps.style.fontFamily = `\"object-fit: ${objectFit}; object-position: ${objectPosition}\"`;\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Image Aspect Ratio used for image placeholder\n    // --------------------------------------------------------------------------------------------\n\n    const aspectRatioBoxProps: AspectRatioBoxPropsType = {};\n\n    if (containerAspectRatio) {\n        // This ensures that lazy-loaded images don't cause the browser scroll to jump once the\n        // image has loaded. It uses the following technique:\n        // https://css-tricks.com/aspect-ratio-boxes/\n        const h = 100000;\n        const w = h * containerAspectRatio;\n\n        aspectRatioBoxProps.style = {\n            paddingTop: `${(h / w) * 100}%`,\n            overflow: 'hidden', // Prevents alt text from taking up space before `src` is populated\n            height: 0,\n        };\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Sources and srcSets\n    // --------------------------------------------------------------------------------------------\n\n    // We separate `webp` from the `jpeg`/`png` so that we can apply the `imgTagSource` directly\n    // onto the `img` tag. While this makes the code messier, it is needed to work around a bug in\n    // Safari:\n    // - https://bugs.webkit.org/show_bug.cgi?id=190031\n    // - https://bugs.webkit.org/show_bug.cgi?id=177068\n\n    const webpSource = find(sources, s => s.type === 'image/webp');\n    const imgTagSource = find(sources, s => s.type === 'image/jpeg' || s.type === 'image/png');\n\n    // --------------------------------------------------------------------------------------------\n    // Image load and error states\n    // --------------------------------------------------------------------------------------------\n\n    const [isLoaded, setIsLoaded] = useState<boolean>(false);\n    const [isError, setIsError] = useState<boolean>(false);\n\n    // --------------------------------------------------------------------------------------------\n    // Combining refs: This component has three refs that need to be combined into one. This\n    // method of combining refs is suggested by `react-intersection-observer`:\n    // https://github.com/thebuilder/react-intersection-observer#how-can-i-assign-multiple-refs-to-a-component\n    // --------------------------------------------------------------------------------------------\n\n    const setRefs = useCallback(\n        node => {\n            // Using a callback `ref` on this `picture` allows us to have multiple `ref`s on one\n            // element.\n            setContainerRef(node);\n\n            // Check if the consumer sets a ref.\n            if (typeof outerRef === 'function') {\n                outerRef(node);\n            }\n        },\n        [outerRef, setContainerRef],\n    );\n\n    return (\n        <>\n            <picture {...rest} className={classNames(styles.picture, className)} ref={setRefs}>\n                {webpSource && (\n                    <source\n                        type={webpSource.type}\n                        // Only add this attribute if lazyload has been triggered.\n                        srcSet={shouldLoadImage ? webpSource.srcSet : undefined}\n                        sizes={sizes}\n                    />\n                )}\n                <img\n                    // The order of `sizes`, `srcSet`, and `src` is important to work around a bug in\n                    // Safari. Once the bug is fixed, we should simplify this by using `src` on the\n                    // `img` tag and using `source` tags.\n                    sizes={sizes}\n                    // Only add this attribute if lazyload has been triggered.\n                    srcSet={shouldLoadImage && imgTagSource ? imgTagSource.srcSet : undefined}\n                    // Only add this attribute if lazyload has been triggered.\n                    src={shouldLoadImage ? src : undefined}\n                    // Height is generally only used for full-width hero images.\n                    height={height}\n                    alt={alt}\n                    // Adds object fit values if specified and adds/removes placeholder padding.\n                    // For SSR we want this to fire instantly.\n                    style={{\n                        ...(shouldObjectFit ? objectFitProps.style : {}),\n                        ...(isLoaded || isError || forceEarlyRender\n                            ? {}\n                            : aspectRatioBoxProps.style),\n                    }}\n                    onLoad={(): void => {\n                        setIsLoaded(true);\n                    }}\n                    onError={(): void => {\n                        setIsError(true);\n                    }}\n                    className={classNames({\n                        // Opacity to 0, prevents flash of alt text when `height` prop used\n                        [styles.imageStart]: true,\n                        // Opacity to 1 to reveal image or show alt text on error\n                        // For SSR we want this to fire instantly.\n                        [styles.imageEnd]: isLoaded || isError || forceEarlyRender,\n                    })}\n                />\n            </picture>\n            {!forceEarlyRender && (\n                <noscript>\n                    <img src={src} alt={alt} />\n                </noscript>\n            )}\n        </>\n    );\n});\n\n// Needed because of the `forwardRef`.\nImage.displayName = 'Image';\n\nexport default Image;\n"]},"metadata":{},"sourceType":"module"}