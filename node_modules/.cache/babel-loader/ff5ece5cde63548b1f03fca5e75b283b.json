{"ast":null,"code":"import { slicedToArray as _slicedToArray } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport React, { useState, useEffect } from 'react';\nimport 'prop-types';\nimport rotate from 'rotate-array';\nimport range from 'lodash/range';\nimport styles from './base-carousel.module.scss';\n\nfunction BaseCarousel(_ref) {\n  var children = _ref.children,\n      _ref$selectedIndex = _ref.selectedIndex,\n      selectedIndex = _ref$selectedIndex === void 0 ? 0 : _ref$selectedIndex,\n      _ref$animationDuratio = _ref.animationDuration,\n      animationDuration = _ref$animationDuratio === void 0 ? 400 : _ref$animationDuratio,\n      _ref$visibleCount = _ref.visibleCount,\n      visibleCount = _ref$visibleCount === void 0 ? 1 : _ref$visibleCount,\n      _ref$spacing = _ref.spacing,\n      spacing = _ref$spacing === void 0 ? '0px' : _ref$spacing; // When animating, `prevSelectedIndex` is the value of `selectedIndex` before the\n  // animation began. Once the animation is complete, it becomes the same as `selectedIndex`.\n\n  var _useState = useState(selectedIndex),\n      _useState2 = _slicedToArray(_useState, 2),\n      prevSelectedIndex = _useState2[0],\n      setPrevSelectedIndex = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isAnimating = _useState4[0],\n      setIsAnimating = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isSuspensed = _useState6[0],\n      setIsSuspensed = _useState6[1];\n\n  function reorder(items) {\n    // The `prevSelectedIndex` doesn't update until the animation is done, so we want to\n    // use that ordering until the animation is complete.\n    return rotate(items, -1 * Math.floor(prevSelectedIndex));\n  }\n\n  useEffect(function () {\n    if (selectedIndex !== prevSelectedIndex) {\n      setIsAnimating(true);\n      setIsSuspensed(false);\n      setTimeout(function () {\n        setIsAnimating(false);\n        setIsSuspensed(true);\n        setPrevSelectedIndex(selectedIndex); // We suspend the CSS animation property for a very brief window before\n        // re-enabling. This gap allows the component to re-render the new list\n        // without the items \"sliding\" back into place. Once the new items are set up,\n        // we re-enable the animation property ready for the next transition.\n\n        setTimeout(function () {\n          setIsSuspensed(false);\n        }, 50);\n      }, animationDuration);\n    }\n  }, [animationDuration, prevSelectedIndex, selectedIndex]);\n  var itemWidth = 1 / visibleCount; // If `selectedIndex` is `1.5`, this value is `0.5`. This is used when the consumer wants\n  // to partially display children.\n\n  var fractionalIndexOffset = Math.abs(prevSelectedIndex - Math.floor(prevSelectedIndex)); // The `adjustedIndex`, when animating, is the number of items to slide. If the value is\n  // negative it means that we should slide to the left. It gets reset to `0` when the\n  // animation is complete.\n\n  var adjustedIndex = selectedIndex - prevSelectedIndex; // This is equal to `fractionalIndexOffset` in the resting state but changes while the\n  // transition is occuring.\n\n  var translateX = itemWidth * (adjustedIndex + fractionalIndexOffset) * -100;\n  var numChildren = React.Children.count(children); // An array of the flex order of the items.\n\n  var childOrders = reorder(range(numChildren)); // Sometimes we need to duplicate the children so that the carousel can display properly.\n  // This is especially needed when animating. Imagine that a 4-item card with 3 visible\n  // items wants to animate 2 items to the right. Normally, this would require 5 items to\n  // animate without displaying an empty spot. Since there are only 4 items, we temporarily\n  // duplicate the `children` until the animation is complete.\n\n  var shouldRenderDuplicateChildren = isAnimating;\n  return React.createElement(\"div\", {\n    className: styles.root\n  }, React.createElement(\"ul\", {\n    className: styles.wrapper,\n    style: {\n      transform: \"translateX(\".concat(translateX, \"%)\"),\n      transition: isSuspensed ? 'none' : \"transform \".concat(animationDuration, \"ms ease\"),\n      width: \"calc(100% + \".concat(spacing, \")\")\n    }\n  }, React.Children.map(children, function (child, i) {\n    return React.createElement(\"li\", {\n      key: i,\n      className: styles.item,\n      style: {\n        width: \"\".concat(itemWidth * 100, \"%\"),\n        paddingRight: spacing,\n        order: childOrders[i]\n      }\n    }, child);\n  }), shouldRenderDuplicateChildren && React.Children.map(children, function (child, index) {\n    return React.createElement(\"li\", {\n      key: numChildren + index,\n      className: styles.item,\n      style: {\n        width: \"\".concat(itemWidth * 100, \"%\"),\n        paddingRight: spacing,\n        order: childOrders[index] + numChildren,\n        transform: \"translateX(\".concat(numChildren * -200, \"%)\")\n      }\n    }, child);\n  }), shouldRenderDuplicateChildren && React.Children.map(children, function (child, index) {\n    return React.createElement(\"li\", {\n      key: numChildren + index * 2,\n      className: styles.item,\n      style: {\n        width: \"\".concat(itemWidth * 100, \"%\"),\n        paddingRight: spacing,\n        order: (childOrders[index] + numChildren) * 2,\n        transform: \"translateX(\".concat(numChildren * -100, \"%)\")\n      }\n    }, child);\n  })));\n}\n\nexport default BaseCarousel;","map":{"version":3,"sources":["../../../../components/Carousel/base-carousel.tsx"],"names":["children","selectedIndex","animationDuration","visibleCount","spacing","prevSelectedIndex","setPrevSelectedIndex","useState","isAnimating","setIsAnimating","isSuspensed","setIsSuspensed","rotate","Math","useEffect","setTimeout","itemWidth","fractionalIndexOffset","adjustedIndex","translateX","numChildren","React","childOrders","reorder","range","shouldRenderDuplicateChildren","styles","root","transform","transition","width","paddingRight","order","index"],"mappings":";;;;;;;AA6Be,SAAA,YAAA,CAAA,IAAA,EAMY;MALvBA,QAKuB,GAAA,IAAA,CALvBA,Q;gCACAC,a;MAAAA,aAIuB,GAAA,kBAAA,KAAA,KAAA,CAAA,GAJP,CAIO,GAAA,kB;mCAHvBC,iB;MAAAA,iBAGuB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAHH,GAGG,GAAA,qB;+BAFvBC,Y;MAAAA,YAEuB,GAAA,iBAAA,KAAA,KAAA,CAAA,GAFR,CAEQ,GAAA,iB;0BADvBC,O;MAAAA,OACuB,GAAA,YAAA,KAAA,KAAA,CAAA,GADb,KACa,GAAA,Y,CAAA,C;;;kBAG2BG,QAAQ,CAHnC,aAGmC,C;;MAAnDF,iBAHgB,GAAA,UAAA,CAAA,CAAA,C;MAGGC,oBAHH,GAAA,UAAA,CAAA,CAAA,C;;mBAIeC,QAAQ,CAJvB,KAIuB,C;;MAAvCC,WAJgB,GAAA,UAAA,CAAA,CAAA,C;MAIHC,cAJG,GAAA,UAAA,CAAA,CAAA,C;;mBAKeF,QAAQ,CALvB,KAKuB,C;;MAAvCG,WALgB,GAAA,UAAA,CAAA,CAAA,C;MAKHC,cALG,GAAA,UAAA,CAAA,CAAA,C;;WAOvB,O,CAAA,K,EAA4C;;;WAGjCC,MAAM,CAAA,KAAA,EAAgB,CAAA,CAAA,GAAKC,IAAI,CAAJA,KAAAA,CAAlC,iBAAkCA,CAArB,C;;;AAGjBC,EAAAA,SAAS,CAAC,YAAM;QACRb,aAAa,KAAjB,iB,EAAyC;AACrCQ,MAAAA,cAAc,CAAdA,IAAc,CAAdA;AACAE,MAAAA,cAAc,CAAdA,KAAc,CAAdA;AAEAI,MAAAA,UAAU,CAAC,YAAM;AACbN,QAAAA,cAAc,CAAdA,KAAc,CAAdA;AACAE,QAAAA,cAAc,CAAdA,IAAc,CAAdA;AACAL,QAAAA,oBAAoB,CAHP,aAGO,CAApBA,CAHa,CAAA;;;;;AASbS,QAAAA,UAAU,CAAC,YAAM;AACbJ,UAAAA,cAAc,CAAdA,KAAc,CAAdA;AADM,SAAA,EAAVI,EAAU,CAAVA;AATM,OAAA,EAAVA,iBAAU,CAAVA;;AALC,GAAA,EAmBN,CAAA,iBAAA,EAAA,iBAAA,EAnBHD,aAmBG,CAnBM,CAATA;MAqBME,SAAS,GAAG,IAlCK,Y,CAAA,CAAA;;;MAsCjBC,qBAAqB,GAAGJ,IAAI,CAAJA,GAAAA,CAASR,iBAAiB,GAAGQ,IAAI,CAAJA,KAAAA,CAtCpC,iBAsCoCA,CAA7BA,C,CAtCP,CAAA;;;;MA2CjBK,aAAa,GAAGjB,aAAa,GA3CZ,iB,CAAA,CAAA;;;MA+CjBkB,UAAU,GAAGH,SAAS,IAAIE,aAAa,GAA1BF,qBAAS,CAATA,GAAsD,CAAzE,G;MAEMI,WAAW,GAAGC,KAAK,CAALA,QAAAA,CAAAA,KAAAA,CAjDG,QAiDHA,C,CAjDG,CAAA;;MAoDjBC,WAAW,GAAGC,OAAO,CAACC,KAAK,CApDV,WAoDU,CAAN,C,CApDJ,CAAA;;;;;;MA2DjBC,6BAA6B,GAAnC,W;SAGI,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,IAAA,SAAS,EAAEC,MAAM,CAACC;AAAvB,GAAA,EACI,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,IAAA,SAAS,EAAED,MAAM,CADrB,OAAA;AAEI,IAAA,KAAK,EAAE;AACHE,MAAAA,SAAS,EAAA,cAAA,MAAA,CAAA,UAAA,EADN,IACM,CADN;AAEHC,MAAAA,UAAU,EAAEnB,WAAW,GAAA,MAAA,GAAA,aAAA,MAAA,CAAA,iBAAA,EAFpB,SAEoB,CAFpB;AAGHoB,MAAAA,KAAK,EAAA,eAAA,MAAA,CAAA,OAAA,EAAA,GAAA;AAHF;AAFX,GAAA,EAQK,KAAK,CAAL,QAAA,CAAA,GAAA,CAAA,QAAA,EAA6B,UAAA,KAAA,EAAA,CAAA,EAAA;WAC1B,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,MAAA,GAAG,EADP,CAAA;AAEI,MAAA,SAAS,EAAEJ,MAAM,CAFrB,IAAA;AAGI,MAAA,KAAK,EAAE;AACHI,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAKd,SAAS,GAAd,GAAA,EADF,GACE,CADF;AAEHe,QAAAA,YAAY,EAFT,OAAA;AAGHC,QAAAA,KAAK,EAAEV,WAAW,CAAA,CAAA;AAHf;AAHX,KAAA,EAD0B,KAC1B,C;AATR,GAQK,CARL,EAuBKG,6BAA6B,IAC1B,KAAK,CAAL,QAAA,CAAA,GAAA,CAAA,QAAA,EAA6B,UAAA,KAAA,EAAA,KAAA,EAAA;WACzB,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,MAAA,GAAG,EAAEL,WAAW,GADpB,KAAA;AAEI,MAAA,SAAS,EAAEM,MAAM,CAFrB,IAAA;AAGI,MAAA,KAAK,EAAE;AACHI,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAKd,SAAS,GAAd,GAAA,EADF,GACE,CADF;AAEHe,QAAAA,YAAY,EAFT,OAAA;AAGHC,QAAAA,KAAK,EAAEV,WAAW,CAAXA,KAAW,CAAXA,GAHJ,WAAA;AAIHM,QAAAA,SAAS,EAAA,cAAA,MAAA,CAAgBR,WAAW,GAAG,CAA9B,GAAA,EAAA,IAAA;AAJN;AAHX,KAAA,EADyB,KACzB,C;AAzBZ,GAwBQ,CAxBR,EAwCKK,6BAA6B,IAC1B,KAAK,CAAL,QAAA,CAAA,GAAA,CAAA,QAAA,EAA6B,UAAA,KAAA,EAAA,KAAA,EAAA;WACzB,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,MAAA,GAAG,EAAEL,WAAW,GAAGa,KAAK,GAD5B,CAAA;AAEI,MAAA,SAAS,EAAEP,MAAM,CAFrB,IAAA;AAGI,MAAA,KAAK,EAAE;AACHI,QAAAA,KAAK,EAAA,GAAA,MAAA,CAAKd,SAAS,GAAd,GAAA,EADF,GACE,CADF;AAEHe,QAAAA,YAAY,EAFT,OAAA;AAGHC,QAAAA,KAAK,EAAE,CAACV,WAAW,CAAXA,KAAW,CAAXA,GAAD,WAAA,IAHJ,CAAA;AAIHM,QAAAA,SAAS,EAAA,cAAA,MAAA,CAAgBR,WAAW,GAAG,CAA9B,GAAA,EAAA,IAAA;AAJN;AAHX,KAAA,EADyB,KACzB,C;AA5CpB,GA2CgB,CAzCR,CADJ,C","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport rotate from 'rotate-array';\nimport range from 'lodash/range';\nimport styles from './base-carousel.module.scss';\n\ninterface PropTypes {\n    /**\n     * The items in the carousel that appear horizontally.\n     */\n    children: React.ReactNode;\n    /**\n     * The index of the left-most item to display in the carousel. Supports all numbers.\n     */\n    selectedIndex?: number;\n    /**\n     * The duration of the animation (in milliseconds).\n     */\n    animationDuration?: number;\n    /**\n     * The number of items that are visible at once.\n     */\n    visibleCount?: number;\n    /**\n     * The amount space separating each item. Supports CSS values such as `8px` or `0.5em`.\n     */\n    spacing?: string;\n}\n\nexport default function BaseCarousel({\n    children,\n    selectedIndex = 0,\n    animationDuration = 400,\n    visibleCount = 1,\n    spacing = '0px',\n}: PropTypes): JSX.Element {\n    // When animating, `prevSelectedIndex` is the value of `selectedIndex` before the\n    // animation began. Once the animation is complete, it becomes the same as `selectedIndex`.\n    const [prevSelectedIndex, setPrevSelectedIndex] = useState<number>(selectedIndex);\n    const [isAnimating, setIsAnimating] = useState<boolean>(false);\n    const [isSuspensed, setIsSuspensed] = useState<boolean>(false);\n\n    function reorder(items: number[]): number[] {\n        // The `prevSelectedIndex` doesn't update until the animation is done, so we want to\n        // use that ordering until the animation is complete.\n        return rotate<number>(items, -1 * Math.floor(prevSelectedIndex));\n    }\n\n    useEffect(() => {\n        if (selectedIndex !== prevSelectedIndex) {\n            setIsAnimating(true);\n            setIsSuspensed(false);\n\n            setTimeout(() => {\n                setIsAnimating(false);\n                setIsSuspensed(true);\n                setPrevSelectedIndex(selectedIndex);\n\n                // We suspend the CSS animation property for a very brief window before\n                // re-enabling. This gap allows the component to re-render the new list\n                // without the items \"sliding\" back into place. Once the new items are set up,\n                // we re-enable the animation property ready for the next transition.\n                setTimeout(() => {\n                    setIsSuspensed(false);\n                }, 50);\n            }, animationDuration);\n        }\n    }, [animationDuration, prevSelectedIndex, selectedIndex]);\n\n    const itemWidth = 1 / visibleCount;\n\n    // If `selectedIndex` is `1.5`, this value is `0.5`. This is used when the consumer wants\n    // to partially display children.\n    const fractionalIndexOffset = Math.abs(prevSelectedIndex - Math.floor(prevSelectedIndex));\n\n    // The `adjustedIndex`, when animating, is the number of items to slide. If the value is\n    // negative it means that we should slide to the left. It gets reset to `0` when the\n    // animation is complete.\n    const adjustedIndex = selectedIndex - prevSelectedIndex;\n\n    // This is equal to `fractionalIndexOffset` in the resting state but changes while the\n    // transition is occuring.\n    const translateX = itemWidth * (adjustedIndex + fractionalIndexOffset) * -100;\n\n    const numChildren = React.Children.count(children);\n\n    // An array of the flex order of the items.\n    const childOrders = reorder(range(numChildren));\n\n    // Sometimes we need to duplicate the children so that the carousel can display properly.\n    // This is especially needed when animating. Imagine that a 4-item card with 3 visible\n    // items wants to animate 2 items to the right. Normally, this would require 5 items to\n    // animate without displaying an empty spot. Since there are only 4 items, we temporarily\n    // duplicate the `children` until the animation is complete.\n    const shouldRenderDuplicateChildren = isAnimating;\n\n    return (\n        <div className={styles.root}>\n            <ul\n                className={styles.wrapper}\n                style={{\n                    transform: `translateX(${translateX}%)`,\n                    transition: isSuspensed ? 'none' : `transform ${animationDuration}ms ease`,\n                    width: `calc(100% + ${spacing})`,\n                }}\n            >\n                {React.Children.map(children, (child, i) => (\n                    <li\n                        key={i}\n                        className={styles.item}\n                        style={{\n                            width: `${itemWidth * 100}%`,\n                            paddingRight: spacing,\n                            order: childOrders[i],\n                        }}\n                    >\n                        {child}\n                    </li>\n                ))}\n\n                {/* Temporary elements that appear to the left. */}\n                {shouldRenderDuplicateChildren &&\n                    React.Children.map(children, (child, index) => (\n                        <li\n                            key={numChildren + index}\n                            className={styles.item}\n                            style={{\n                                width: `${itemWidth * 100}%`,\n                                paddingRight: spacing,\n                                order: childOrders[index] + numChildren,\n                                transform: `translateX(${numChildren * -200}%)`,\n                            }}\n                        >\n                            {child}\n                        </li>\n                    ))}\n\n                {/* Temporary elements that appear to the right. */}\n                {shouldRenderDuplicateChildren &&\n                    React.Children.map(children, (child, index) => (\n                        <li\n                            key={numChildren + index * 2}\n                            className={styles.item}\n                            style={{\n                                width: `${itemWidth * 100}%`,\n                                paddingRight: spacing,\n                                order: (childOrders[index] + numChildren) * 2,\n                                transform: `translateX(${numChildren * -100}%)`,\n                            }}\n                        >\n                            {child}\n                        </li>\n                    ))}\n            </ul>\n        </div>\n    );\n}\n"]},"metadata":{},"sourceType":"module"}