{"ast":null,"code":"import { slicedToArray as _slicedToArray } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport { useState, useRef, useEffect } from 'react';\nimport forEach from 'lodash/forEach';\nimport getScrollParent from './get-scroll-parent.js';\n\nfunction getIntersectionObserverRoot(target) {\n  var parent = getScrollParent(target);\n  return parent && (parent.tagName === 'HTML' || parent.tagName === 'BODY') ? null : parent;\n}\n\nfunction useLazyLoad(el, browserSupportIntersectionObserver) {\n  // The total number of Intersection Observers that we end up creating. We create one for each\n  // scrollable parent element of `el`. An image within a carousel, for example, could have two\n  // scrollable parents: the carousel and the `<body>` element. We'd load the image if it is\n  // visible within the carousel and the carousel is visible within the body.\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      numObservers = _useState2[0],\n      setNumObservers = _useState2[1]; // The number of Intersection Observers we've created that have intersected.\n\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      numHaveIntersected = _useState4[0],\n      setNumHaveIntersected = _useState4[1]; // We store the Intersection Observer instances so that we can clean them up in the `useEffect`\n  // return function.\n\n\n  var observers = useRef([]);\n  useEffect(function () {\n    if (el && browserSupportIntersectionObserver) {\n      // Get array of targets and roots to use with Intersection Observer. `target` is the\n      // child element and `root` is the scrollable parent. This terminology comes from the\n      // Insersection Observer itself:\n      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n      var observersToCreate = []; // The first target is always the element passed in.\n\n      var target = el;\n      var root = getIntersectionObserverRoot(target);\n      observersToCreate.push({\n        target: target,\n        root: root\n      }); // If `root !== null`, that means that there is another scrollable parent. Continue\n      // traversing up the DOM tree until we get to the top.\n\n      while (root !== null) {\n        target = root;\n        root = getIntersectionObserverRoot(target);\n        observersToCreate.push({\n          target: target,\n          root: root\n        });\n      } // We later use the total number of observers to determine if they are all visible.\n\n\n      setNumObservers(observersToCreate.length); // Take the array of targets and roots and create a bunch of Intersection Observers.\n\n      observers.current = observersToCreate.map(function (p) {\n        // We disable this line since we polyfill `IntersectionObserver`.\n        // eslint-disable-next-line compat/compat\n        var observer = new IntersectionObserver(function (entries) {\n          // We can assume it's the first one since we only observe one target per\n          // IntersectionObserver.\n          var entry = entries[0]; // We use both `isIntersecting` and `intersectionRatio` because Edge 15\n          // doesn't support `isIntersecting`.\n\n          if (entry.isIntersecting || entry.intersectionRatio > 0) {\n            // We need to pass in a function to `setNumHaveIntersected` so that it\n            // can get the current value of `numHaveIntersected` within this\n            // callback.\n            setNumHaveIntersected(function (n) {\n              return n + 1;\n            }); // We turn off the observer once it has intersected. This is a purposely\n            // naïve approach even though it introduces a small bug: images within\n            // an auto-advancing carousel that once were `isIntersecting`\n            // within the carousel but been auto-advanced out of view will get\n            // loaded once the user scrolls and the carousel intersects the\n            // `<body>`. To fix this, we'd have to increment and decrement\n            // `observer.current`'s and then turn them all off once the image should\n            // be loaded. This would add lot of complexity for an uncommon case so\n            // we leave it as is.\n\n            observer.unobserve(entry.target);\n          }\n        }, {\n          root: p.root,\n          rootMargin: '100px'\n        });\n        observer.observe(p.target);\n        return observer;\n      });\n    }\n\n    return function cleanObservers() {\n      forEach(observers.current, function (o) {\n        return o.disconnect();\n      });\n    };\n  }, [el, browserSupportIntersectionObserver]); // The image should load if there's at least one Intersection Observer set up and all of them\n  // have intersected. The `> 0` check prevents the hook from returning true while before it has\n  // even initialized.\n\n  return numObservers > 0 && numObservers === numHaveIntersected;\n}\n\nexport default useLazyLoad;","map":{"version":3,"sources":["../../../../components/Image/use-lazy-load.ts"],"names":["parent","scrollparent","numObservers","setNumObservers","useState","numHaveIntersected","setNumHaveIntersected","observers","useRef","useEffect","el","observersToCreate","target","root","getIntersectionObserverRoot","observer","entry","entries","n","p","rootMargin","forEach","o"],"mappings":";;;;;AAIA,SAAA,2BAAA,CAAA,MAAA,EAAsE;MAC5DA,MAAM,GAAGC,eAAY,CAA3B,MAA2B,C;SACpBD,MAAM,KAAKA,MAAM,CAANA,OAAAA,KAAAA,MAAAA,IAA6BA,MAAM,CAANA,OAAAA,KAAxCA,MAAM,CAANA,GAAAA,IAAAA,GAAP,M;;;AAGW,SAAA,WAAA,CAAA,EAAA,EAAA,kCAAA,EAGJ;;;;;kBAKiCI,QAAQ,CALzC,CAKyC,C;;MAAzCF,YALA,GAAA,UAAA,CAAA,CAAA,C;MAKcC,eALd,GAAA,UAAA,CAAA,CAAA,C,CAAA,CAAA;;;mBAO6CC,QAAQ,CAPrD,CAOqD,C;;MAArDC,kBAPA,GAAA,UAAA,CAAA,CAAA,C;MAOoBC,qBAPpB,GAAA,UAAA,CAAA,CAAA,C,CAAA,CAAA;;;;MAUDC,SAAS,GAAGC,MAAM,CAAxB,EAAwB,C;AAExBC,EAAAA,SAAS,CAAC,YAAM;QACRC,EAAE,IAAN,kC,EAA8C;;;;;UAKpCC,iBAA8D,GAL1B,E,CAAA,CAAA;;UAQtCC,MAAM,GAAV,E;UACIC,IAAI,GAAGC,2BAA2B,CAAtC,MAAsC,C;AAEtCH,MAAAA,iBAAiB,CAAjBA,IAAAA,CAAuB;AAAEC,QAAAA,MAAM,EAAR,MAAA;AAAUC,QAAAA,IAAI,EAAJA;AAAV,OAAvBF,EAX0C,CAAA;;;aAenCE,IAAI,KAAX,I,EAAsB;AAClBD,QAAAA,MAAM,GAANA,IAAAA;AACAC,QAAAA,IAAI,GAAGC,2BAA2B,CAAlCD,MAAkC,CAAlCA;AACAF,QAAAA,iBAAiB,CAAjBA,IAAAA,CAAuB;AAAEC,UAAAA,MAAM,EAAR,MAAA;AAAUC,UAAAA,IAAI,EAAJA;AAAV,SAAvBF;AAlBsC,OAAA,CAAA;;;AAsB1CR,MAAAA,eAAe,CAACQ,iBAAiB,CAtBS,MAsB3B,CAAfR,CAtB0C,CAAA;;AAyB1CI,MAAAA,SAAS,CAATA,OAAAA,GAAoB,iBAAiB,CAAjB,GAAA,CAAsB,UAAA,CAAA,EAAK;;;YAGrCQ,QAAQ,GAAG,IAAA,oBAAA,CACb,UAAA,OAAA,EAAW;;;cAGDC,KAAK,GAAGC,OAAO,CAHd,CAGc,C,CAHd,CAAA;;;cAOHD,KAAK,CAALA,cAAAA,IAAwBA,KAAK,CAALA,iBAAAA,GAA5B,C,EAAyD;;;;AAIrDV,YAAAA,qBAAqB,CAAC,UAAA,CAAA,EAAC;qBAAIY,CAAC,GAAL,C;AAJ8B,aAIhC,CAArBZ,CAJqD,CAAA;;;;;;;;;;AAcrDS,YAAAA,QAAQ,CAARA,SAAAA,CAAmBC,KAAK,CAAxBD,MAAAA;;AAtBK,SAAA,EAyBb;AACIF,UAAAA,IAAI,EAAEM,CAAC,CADX,IAAA;AAEIC,UAAAA,UAAU,EAAE;AAFhB,SAzBa,C;AA+BjBL,QAAAA,QAAQ,CAARA,OAAAA,CAAiBI,CAAC,CAAlBJ,MAAAA;eAEA,Q;AApCJR,OAAoB,CAApBA;;;WAwCG,SAAA,cAAA,GAAgC;AACnCc,MAAAA,OAAO,CAACd,SAAS,CAAV,OAAA,EAAoB,UAAA,CAAA,EAAC;eAAIe,CAAC,CAAL,UAAIA,E;AAAhCD,OAAO,CAAPA;AADJ,K;AAlEK,GAAA,EAqEN,CAAA,EAAA,EAjFI,kCAiFJ,CArEM,CAATZ,CAZO,CAAA;;;;SAsFAP,YAAY,GAAZA,CAAAA,IAAoBA,YAAY,KAAvC,kB","sourcesContent":["import { useRef, useState, useEffect } from 'react';\nimport forEach from 'lodash/forEach';\nimport scrollparent from './get-scroll-parent';\n\nfunction getIntersectionObserverRoot(target: Element): Element | null {\n    const parent = scrollparent(target);\n    return parent && (parent.tagName === 'HTML' || parent.tagName === 'BODY') ? null : parent;\n}\n\nexport default function useLazyLoad(\n    el: Element | null,\n    browserSupportIntersectionObserver: boolean,\n): boolean {\n    // The total number of Intersection Observers that we end up creating. We create one for each\n    // scrollable parent element of `el`. An image within a carousel, for example, could have two\n    // scrollable parents: the carousel and the `<body>` element. We'd load the image if it is\n    // visible within the carousel and the carousel is visible within the body.\n    const [numObservers, setNumObservers] = useState<number>(0);\n    // The number of Intersection Observers we've created that have intersected.\n    const [numHaveIntersected, setNumHaveIntersected] = useState<number>(0);\n    // We store the Intersection Observer instances so that we can clean them up in the `useEffect`\n    // return function.\n    const observers = useRef<IntersectionObserver[]>([]);\n\n    useEffect(() => {\n        if (el && browserSupportIntersectionObserver) {\n            // Get array of targets and roots to use with Intersection Observer. `target` is the\n            // child element and `root` is the scrollable parent. This terminology comes from the\n            // Insersection Observer itself:\n            // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n            const observersToCreate: { target: Element; root: Element | null }[] = [];\n\n            // The first target is always the element passed in.\n            let target = el;\n            let root = getIntersectionObserverRoot(target);\n\n            observersToCreate.push({ target, root });\n\n            // If `root !== null`, that means that there is another scrollable parent. Continue\n            // traversing up the DOM tree until we get to the top.\n            while (root !== null) {\n                target = root;\n                root = getIntersectionObserverRoot(target);\n                observersToCreate.push({ target, root });\n            }\n\n            // We later use the total number of observers to determine if they are all visible.\n            setNumObservers(observersToCreate.length);\n\n            // Take the array of targets and roots and create a bunch of Intersection Observers.\n            observers.current = observersToCreate.map(p => {\n                // We disable this line since we polyfill `IntersectionObserver`.\n                // eslint-disable-next-line compat/compat\n                const observer = new IntersectionObserver(\n                    entries => {\n                        // We can assume it's the first one since we only observe one target per\n                        // IntersectionObserver.\n                        const entry = entries[0];\n\n                        // We use both `isIntersecting` and `intersectionRatio` because Edge 15\n                        // doesn't support `isIntersecting`.\n                        if (entry.isIntersecting || entry.intersectionRatio > 0) {\n                            // We need to pass in a function to `setNumHaveIntersected` so that it\n                            // can get the current value of `numHaveIntersected` within this\n                            // callback.\n                            setNumHaveIntersected(n => n + 1);\n                            // We turn off the observer once it has intersected. This is a purposely\n                            // naïve approach even though it introduces a small bug: images within\n                            // an auto-advancing carousel that once were `isIntersecting`\n                            // within the carousel but been auto-advanced out of view will get\n                            // loaded once the user scrolls and the carousel intersects the\n                            // `<body>`. To fix this, we'd have to increment and decrement\n                            // `observer.current`'s and then turn them all off once the image should\n                            // be loaded. This would add lot of complexity for an uncommon case so\n                            // we leave it as is.\n                            observer.unobserve(entry.target);\n                        }\n                    },\n                    {\n                        root: p.root,\n                        rootMargin: '100px',\n                    },\n                );\n\n                observer.observe(p.target);\n\n                return observer;\n            });\n        }\n\n        return function cleanObservers(): void {\n            forEach(observers.current, o => o.disconnect());\n        };\n    }, [el, browserSupportIntersectionObserver]);\n\n    // The image should load if there's at least one Intersection Observer set up and all of them\n    // have intersected. The `> 0` check prevents the hook from returning true while before it has\n    // even initialized.\n    return numObservers > 0 && numObservers === numHaveIntersected;\n}\n"]},"metadata":{},"sourceType":"module"}